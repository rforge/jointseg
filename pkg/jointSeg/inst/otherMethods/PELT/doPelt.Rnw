% \VignetteIndexEntry{Pruned Exact Linear Time}
% \VignetteIndexEntry{Pelt}
%\VignetteEngine{knitr::knitr}

\documentclass{article} 
\usepackage[latin1]{inputenc}
\usepackage{color, pdfcolmk}
\usepackage{geometry}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\usepackage{hyperref}
\title{How to run an external segmentation method using the \code{jointseg} package}
\author{M. Pierre-Jean, G. Rigaill, P. Neuvial}

\newcommand{\code}[1]{\texttt{#1}}

<<setup, include=FALSE, cache=FALSE, show=FALSE>>=
library(knitr)
# set global chunk options
opts_chunk$set(fig.path='fig/PSSeg-', fig.align='center', fig.show='hold')
options(replace.assign=TRUE,width=90)
@ 

\begin{document}

<<include=FALSE>>=
opts_chunk$set(dev='png', fig.width=5, fig.height=5)
@

\setkeys{Gin}{width=0.8\textwidth}
\maketitle

\begin{abstract}
In this vignette, we show how an external/novel segmentation function (that is, a function not already included in the \code{jointseg}  package) may be compared to existing ones.  For the sake of illustration we chose the  PELT (Pruned Exact Linear Time) segementation method \cite{killick11optimal}.
\end{abstract}

\tableofcontents

<<message=FALSE>>=
library(jointseg)
@ 

\section{Generate data to be segmented}

We use data from a public SNP array data set, which is distributed in the \code{acnr} package (on which the \code{jointseg} package depends).

<<data>>=
data <- loadCnRegionData(dataSet="GSE29172", tumorFraction=1)
str(data)
@ 

<<createProfile>>=
K <- 5
len <- 2e4
sim <- getCopyNumberDataByResampling(len, K, minLength=500, regData=data)
datS <- sim$profile
str(datS)
@ 

The resulting copy-number profile is plotted below.
<<profile-fig>>=
plotSeg(datS, sim$bkp)
@ 


\section{PSSeg segmentation using PELT}
\subsection{Create \code{doPelt} function}
We choose to run the segmentation function PELT (Pruned Exact Linear Time) \cite{killick11optimal}. The integration of a new function consists in two steps:
\begin{enumerate}
\item create a wrapper function for the desired segmentation method.
\item call this wrapper through the \code{PSSeg} function
\end{enumerate}
<<doPelt, tidy=FALSE>>=
doPelt <- function(# Run Pelt segmentation,
                   y,
### A numeric vector or one column matrix, the signal to be segmented
                   ...
### Parameters for cpt.mean function
                   ){
  cpt <- changepoint::cpt.mean(y, method="PELT", ...)
  res <- list(bkp=cpt@cpts[-length(cpt@cpts)])
  return(res) 
}
@ 

We set the \code{argument} \code{method} to \code{"other"} and define the segmentation function to use with the \code{argument} \code{segFUN}.  In the example below we specify the option \code{stat=''c'''} in order to segment total copy numbers.

<<PSSeg>>=
res <- PSSeg(datS, method="other", segFUN=doPelt, stat="c")
@ 

The \code{PSSeg} function returns (as usual):
\begin{itemize}
\item the original segmentation by \code{PELT};
<<>>=
res$initBkp
@ 
\item the result of pruning this original segmentation by dynamic programming, which returns the best segmentation with $k$ breakpoints among the original $K$ ones, for each $k \in \{1, 2, \dots K\}$.
\item the best model (among those selected by dynamic programming) according to the criterion proposed by \cite{lebarbier05detecting}.
\end{itemize}

\subsection{Result evaluation}

<<>>=
print(getTpFp(res$bestBkp, sim$bkp, tol=5))
@ 

Obviously, this performance measure depends on the chosen tolerance:

<<>>=
perf <- sapply(0:5, FUN=function(tol) {
  getTpFp(res$bestBkp, sim$bkp, tol=tol)
})
print(perf)
@ 

\section{Performance comparison with other methods on a single genomic profile}
<<>>=
resList <- list()
stat <- "c"

resList[["Pelt"]] <- PSSeg(datS, method="other", segFUN=doPelt, stat=stat)$initBkp

Kmax <- 20
resList[["RBS"]] <- PSSeg(datS, method="RBS", stat=stat, K=Kmax)$bestBkp
resList[["GFLars"]] <- PSSeg(datS, method="GFLars", stat=stat, K=Kmax)$bestBkp
resList[["DP"]] <- PSSeg(datS, method="DynamicProgramming", stat=stat, K=Kmax)$bestBkp
@ 


<<>>=
ev <- sapply(resList, FUN=function(bkp) {
  getTpFp(bkp, sim$bkp, tol=5)
})
ev
@ 

<<results="asis", echo=FALSE>>=
if (require(xtable)) {
  print(xtable(ev, caption="Toy comparison of the performance of segmentation methods on a single profile run.", label="tab:perf", table.placement = "!h", caption.placement="bottom", digits=0))
}
@ 

\appendix
\section*{Appendix}
\addcontentsline{toc}{section}{Appendix}

\section{Session information}
<<sessionInfo>>=
sessionInfo()
@ 
\bibliographystyle{plain}
\bibliography{jointSeg}
\end{document}
